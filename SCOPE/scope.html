<!DOCTYPE html>
<html lang="fr">
	<head>
		<script defer>
			class Scope {
				/**
				 * @description -  ðŸŒˆ - La **rÃ©fÃ©rence** de la fonction est passÃ©e pour l'eventListener
				 * @description - On ne pourra pas utiliser les membres de la classes car le **scope (this) Ã  changÃ©** et fait rÃ©fÃ©rence Ã  #document
				 * @description - â˜€ï¸ -
				 * @description - ðŸ’¥ - Si on fait removeEventListener en utilisant une **fonction flÃ©chÃ©e** (ligne du dessous), celui-ci ne sera **pas retirÃ©** (pas de rÃ©fÃ©rence Ã  la fonction)
				 * */
				constructor() {
					this.message = "COUCOU"

					// Add event listeners
					document.addEventListener("click", this.callFunctionReference) // calls function reference
					document.addEventListener("click", () => this.callWithArrowFunction()) // execute function

					// Remove event listeners aprÃ¨s 3s
					setTimeout(() => {
						console.log(
							"\n %clisteners Removed \n",
							"font-weight: black; text-transform : uppercase; background-color: white; color: red; font-size: 32px"
						)
						document.removeEventListener("click", this.callFunctionReference)
						/*document.removeEventListener("click", () => this.callWithoutParenthesis()) // Cette fois-ci ne retirera pas l' eventListener*/

						document.removeEventListener("click", this.callWithArrowFunction)
						/*document.removeEventListener("click", () => this.callWithArrowFunction()) // MÃªme rÃ©sultat que ligne prÃ©cÃ©dente car dans l'eventListener, la fonction est appelÃ©e avec une fonction flÃ©chÃ©e et non une rÃ©fÃ©rence de celle-ci...*/
					}, 3000)
				}

				callFunctionReference() {
					console.log(`
1. document.addEventListener("click", this.callWithoutParenthesis):

	- On utilise la reference de la fonction dans l'event listener
	- reference = fonction sans ()
	- Si on appelle la meme reference dans 'removeEnventListener', l'evenement sera supprimee
	- Le probleme est que l'on ne pourra pas utiliser les membres de la classe car le scope est changÃ©...
		La variable this.message, declaree en constructor n'est plus reconnue : ${this.message}
		=> comment faire pour utiliser des props dans la fonction si le scope est change?
							`)
					console.warn(this) // Scopes #Document
					console.log(`
					\n`)
				}

				callWithArrowFunction() {
					console.log(`
2. document.addEventListener("click", () => this.callWithArrowFunction())

	- On utilise la fonction flechee dans l'event listener
	- Si on appelle la meme fonction dans 'removeEnventListener', l'evenement ne sera PAS supprimee
	- cependant le scope reste inchangee, et l'on a access aux membres de la classe...
		Le message est reconnu : ${this.message}
						`)
					console.warn(this)
					console.log(`
	\n`)
				}
			}

			// Lancer une nouvelle instance de Scope
			new Scope()
		</script>

		<style>
			html {
				font-family: sans-serif;
				text-align: center;
			}

			body {
				display: grid;
				place-content: center;
			}

			p:first-of-type {
				font-weight: bold;
			}

			p:last-of-type {
				color: tomato;
			}
		</style>
		<title>SCOPE</title>
	</head>
	<body>
		<h1>Scope test</h1>
		<p>OUVRIR LA CONSOLE ET RECHARGER LE DOCUMENT</p>
		<p>CLIQUER SUR LE DOCUMENT pour voir les messages apparaitre dans la console</p>
	</body>
</html>
